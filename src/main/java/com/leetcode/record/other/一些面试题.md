# 一部分面试题

## 第一题(简单)

原题: [三数之和](https://leetcode.cn/problems/3sum/description/)

给你三个整数数组 nums1、nums2、nums3 以及一个整数 target，数组长度不定且不同数组长度不一定相同 ，请你计算是否有元组 (i, j, k) 能满足：

- nums1[i] + nums2[j] + nums3[k] == target

如果有，返回满足的数组下标 [[i, j, k], ...]。

### 示例1

```shell
log.info("{}", new No1().result(new int[]{-1, 2, 0}, new int[]{-1, 2, 1}, new int[]{-1, 2, 0}, 0));

输出:
[[0, 0, 1], [0, 1, 0], [0, 2, 2], [1, 0, 0], [2, 2, 0]]
```

### 示例2

```shell
log.info("{}", new No1().result(new int[]{0, 0}, new int[]{0, 0}, new int[]{0, 0, 0}, 0));

输出:
[[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 0], [0, 1, 1], [0, 1, 2], [1, 0, 0], [1, 0, 1], [1, 0, 2], [1, 1, 0], [1, 1, 1], [1, 1, 2]]
```

### 示例3

```shell
log.info("{}", new No1().result(new int[]{7, -3}, new int[]{0}, new int[]{-4, 0, 6}, 3));

输出:
[[0, 0, 0], [1, 0, 2]]
```

### 示例4

```shell
log.info("{}", new No1().result(new int[]{0, 2, 8}, new int[]{-2, 0}, new int[]{0, -3, 0}, 6));

输出:
[[2, 0, 0], [2, 0, 2]]
```

## 第二题(简单，但是有一步容易漏)

是第一题的变种，给你三个整数数组 nums1、nums2、nums3 以及一个整数 target，数组长度不定且不同数组长度不一定相同 ，

可以从这三个整数数组中选取任意个，被选取的数组中每个数组选取一个下标，要求这些下标对应的整数相加等于target。未选中的数组对应的下标为：-1。

例如：

- 输入：nums1: [1, 1, 1], nums2: [0, 0, 0], nums3: [3, 3, -1], target: 0
- 输出：[[0, 0, 2], [0, 1, 2], [0, 2, 2], [0, -1, 2], [1, 0, 2], [1, 1, 2], [1, 2, 2], [1, -1, 2], [2, 0, 2], [2, 1, 2], [2, 2, 2], [2, -1, 2], [-1, 0, -1], [-1, 1, -1], [-1, 2, -1], [-1, -1, -1]]
- 注意：都不选取认为结果为0

如果有，返回满足的数组下标。

### 示例1-5

```shell
log.info("{}", new No2().result(new int[]{1, 1, 1}, new int[]{0, 0, 0}, new int[]{3, 3, -1}, 0));
输出:[[0, 0, 2], [0, 1, 2], [0, 2, 2], [0, -1, 2], [1, 0, 2], [1, 1, 2], [1, 2, 2], [1, -1, 2], [2, 0, 2], [2, 1, 2], [2, 2, 2], [2, -1, 2], [-1, 0, -1], [-1, 1, -1], [-1, 2, -1], [-1, -1, -1]]

log.info("{}", new No2().result(new int[]{-1, 2, 0}, new int[]{-1, 2, 1}, new int[]{-1, 2, 0}, 0));
输出:[[0, 0, 1], [0, 1, 0], [0, 2, 2], [0, 2, -1], [1, 0, 0], [2, 2, 0], [2, -1, 2], [2, -1, -1], [-1, 2, 0], [-1, -1, 2], [-1, -1, -1]]

log.info("{}", new No2().result(new int[]{0, 0}, new int[]{0, 0}, new int[]{0, 0, 0}, 0));
输出:[[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, -1], [0, 1, 0], [0, 1, 1], [0, 1, 2], [0, 1, -1], [0, -1, 0], [0, -1, 1], [0, -1, 2], [0, -1, -1], [1, 0, 0], [1, 0, 1], [1, 0, 2], [1, 0, -1], [1, 1, 0], [1, 1, 1], [1, 1, 2], [1, 1, -1], [1, -1, 0], [1, -1, 1], [1, -1, 2], [1, -1, -1], [-1, 0, 0], [-1, 0, 1], [-1, 0, 2], [-1, 0, -1], [-1, 1, 0], [-1, 1, 1], [-1, 1, 2], [-1, 1, -1], [-1, -1, 0], [-1, -1, 1], [-1, -1, 2], [-1, -1, -1]]

log.info("{}", new No2().result(new int[]{7, -3}, new int[]{0}, new int[]{-4, 0, 6}, 3));
输出:[[0, 0, 0], [0, -1, 0], [1, 0, 2], [1, -1, 2]]

log.info("{}", new No2().result(new int[]{0, 2, 8}, new int[]{-2, 0}, new int[]{0, -3, 0}, 6));
输出:[[2, 0, 0], [2, 0, 2], [2, 0, -1]]
```

## 第三题(这个说实话有点不好想，但是想通了很简单)

题目原型：[灯泡开关](https://leetcode.cn/problems/bulb-switcher/)

有一段长度为n的数组，假设初始值全部为0。这个数组会经过n次操作：

1. 第一次，将每个元素都+1 [1][1][1][1]...
2. 第二次，每两个元素第二个元素+1 [1][2][1][2]...
3. 第三次，每三个元素第三个元素+1 [1][2][2][2]...
4. ...

最终，数组中元素最大的值是什么。

### 示例

本质上是求 0 - n 内约数最多问题。数组内每个元素都会在对应下标为i约数的时候+1，例如：8的约数为1 2 4 8，i = 1、2、4、8时，下标为(7 + 1) = 8的元素就+1。

```shell
log.info("{}", new No3().result(4));
输出:3

log.info("{}", new No3().result(64));
输出:12

log.info("{}", new No3().result(100));
输出:12

log.info("{}", new No3().result(20));
输出:6

log.info("{}", new No3().result(256));
输出:20

log.info("{}", new No3().result(1));
输出:1
```

## 第四题

原题: [最大数](https://leetcode.cn/problems/largest-number/description/)

给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最小的整数。

为了方便起见，可以认为数组中不包含'0'。

例如：

- 输入: [1, 2, 3]
- 输出: 123

### 示例1-5

```shell
log.info("{}", new No4().result(new int[]{3, 2, 1}));
输出:123

log.info("{}", new No4().result(new int[]{10, 2}));
输出:102

log.info("{}", new No4().result(new int[]{3, 30, 34, 5, 9}));
输出:3033459

log.info("{}", new No4().result(new int[]{100, 71, 7, 32, 23}));
输出:1002332717

log.info("{}", new No4().result(new int[]{3, 3, 3, 5, 9, 1}));
输出:133359
```

## 第五题

原题: [有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

例如：

- 输入: 3
- 输出: ["((()))","(()())","(())()","()(())","()()()"]

### 示例

```shell
log.info("{}", new MySolution().generateParenthesis(1));
输出: ["()"]

log.info("{}", new MySolution().generateParenthesis(2));
输出: ["(())", "()()"]

log.info("{}", new MySolution().generateParenthesis(3));
输出: ["((()))", "(()())", "(())()", "()(())", "()()()"]

log.info("{}", new MySolution().generateParenthesis(4));
输出: ["(((())))", "((()()))", "((())())", "((()))()", "(()(()))", "(()()())", "(()())()", "(())(())", "(())()()", "()((()))", "()(()())", "()(())()", "()()(())", "()()()()"]
```