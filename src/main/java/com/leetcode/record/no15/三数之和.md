# No 15 三数之和

## 题目

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

### 示例1

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

### 示例2

输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。

### 示例3

输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。

## 题解

### 我的思路

受两数之和的影响，我们可以考虑能否将题目简化为：

1. 先随机选取一个元素，剩下的元素组成的两数之和是否等于这个选择的元素
2. 和两数之和不同，这道题的两数之和可能出现多解，而最后产出的结果只要求值，并不要求下标
3. 但是解不得重复

以数学公式来说明，假设a、b、c都是数组中下标不同的元素，即：a + b + c = 0，这个时候需要考虑的是如何防止b + a + c、 c + a + b等结果的出现。

我们把最先遇到的a + b + c存储起来，存储的结构是：a -> min(b, c) -> max(b, c)。

这个时候我们把a + c -> min(a, c)和a + b -> min(a, b)存起来，当遇到b + a + c或c + a + b时，获取-b -> min(a, c)或-c -> min(a, b)，如果存在就丢弃。

### 官方题解

先从小到大排序，在需要三个元素的情况下，先固定前两个，指针平移第三个。

最开始，三个指针的下标分别位于：0、1、length - 1，这个时候计算一次是否s[0] + s[1] + s[length - 1]：

1. 当这个时候s[0] + s[1] + s[length - 1] <= 0时，直接向右移动第二个指针即可
2. 当这个时候s[0] + s[1] + s[length - 1] > 0时，需要向左移动第三个指针
3. 当第二个指针和第三个指针下标一致后，需要移动第一个指针并重复
4. 每次移动指针，如果和上一次的元素一样，就需要继续移动

### 一个看不懂的题解

依然是先针对数组排序，假设现在一个数组如下：

n = [-4, -1, -1, 0, 1, 2]

1. 先判断这个数组中能否使用三个数组成0，方法很简单：n[0] + n[1] + n[2] <= 0 && n[length - 3] + n[length - 2] + n[length - 1] >= 0
2. 既然这个数组能使用三个数组成0，那么我们删掉最后一位(n[5] = 2)，再来一次；
   1. 重复过程1：-4 + -1 + -1 < 0 && -1 + 0 + 1 = 0
   2. 发现还可以，那就再删掉最后一位(n[4] = 1)，再来一次：
      1. 重复过程1：-4 + -1 + -1 < 0 && -1 + -1 + 0 < 0
      2. 发现不能组成了，把最后一位再加上(n[4] = 1)
   3. 这个时候发现 最后一位(n[4] = 1) + 2*第一位(n[0] = -4) < 0，意味着最后一位可能可以是结果的一部分；这个时候我们将最后一位加入候选，这时就变成了从[-4, -1, -1, 0]中选择2个数字的和为-1
      1. 两数之和比较好理解，因为已经是排序后的数组了，双指针左右向中间一扫就出结果了
      2. 把两数结果和候选结果一起加入结果集，将两数结果剔除候选队列
   4. 将最后一位(n[4] = 1)剔除候选队列
3. 这个时候我们发现，最后一位(n[5] = 2) + 2*第一位(n[0] = -4) < 0，意味着最后一位可能可以是结果的一部分；这个时候我们将最后一位加入候选，这时就变成了从[-4, -1, -1, 0, 1]中选择2个数字的和为-2
   1. 重复两数之和
4. 将最后一位(n[5] = 2)剔除候选队列